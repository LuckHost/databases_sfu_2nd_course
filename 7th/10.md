# Анализ проблем сериализации в транзакциях бронирования

## Задание 1: Объяснение ошибки сериализации

### Почему транзакции не удалось сериализовать?

1. **Механизм Serializable Snapshot Isolation (SSI)** в PostgreSQL обнаружил потенциальную аномалию:
   - Транзакция 1 читала данные о рейсе 13881, затем вставляла билет на этот рейс
   - Транзакция 2 читала данные о рейсе 5572, затем вставляла билет на этот рейс
   - Система не может гарантировать, что такой порядок выполнения эквивалентен последовательному

2. **Техническая причина**:
   - PostgreSQL отслеживает зависимости чтения/записи между транзакциями
   - Обнаружена круговая зависимость (транзакции влияют на общий набор данных)

3. **Почему индекс может помочь?**
   - С индексом по `flight_id` система точнее определяет конфликтующие наборы данных
   - Без индекса сканирование таблицы может захватывать больше строк, чем нужно
   - В документации указано, что индексы помогают SSI точнее определять реальные конфликты

### Решения для успешного выполнения:

1. **Создать индекс**:
   ```sql
   CREATE INDEX idx_ticket_flights_flight_id ON ticket_flights(flight_id);
   ```
   Это уменьшит количество ложных конфликтов.

2. **Понизить уровень изоляции** до Repeatable Read:
   ```sql
   BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;
   ```

## Задание 2: Эксперимент с измененными SELECT

### После изменения условий SELECT:
- Транзакция 1: `SELECT ... WHERE flight_id = 5572` (но вставляет в 13881)
- Транзакция 2: `SELECT ... WHERE flight_id = 13881` (но вставляет в 5572)

### Почему индекс не помогает в этом случае?

1. **Фундаментальный конфликт**:
   - Транзакции читают и изменяют перекрестные данные
   - Это создает явную циклическую зависимость (транзакция 1 → данные 5572 → транзакция 2 → данные 13881 → транзакция 1)

2. **Реальная аномалия сериализации**:
   - Результат параллельного выполнения не эквивалентен ни одному последовательному порядку
   - PostgreSQL корректно определяет это как несериализуемую ситуацию

3. **Индекс бесполезен**, потому что:
   - Конфликт не в эффективности доступа, а в логике доступа к данным
   - Транзакции действительно конфликтуют по данным, а не из-за ложного срабатывания

### Что делать в таком случае?

1. **Перепроектировать логику транзакций**:
   - Читать только те данные, которые будут изменяться
   - Использовать явные блокировки (`SELECT ... FOR UPDATE`)

2. **Реализовать повторные попытки**:
   ```python
   for attempt in 3:
       try:
           execute_transaction()
           break
       except SerializationError:
           continue
   ```

3. **Использовать очереди** для обработки конфликтующих операций

## Выводы

1. Уровень Serializable строго контролирует согласованность, но требует:
   - Аккуратного проектирования транзакций
   - Подходящих индексов для минимизации ложных конфликтов
   - Механизмов обработки ошибок сериализации

2. В высококонкурентных системах бронирования лучше использовать:
   - Read Committed + точечные блокировки
   - Оптимистичные блокировки с проверкой версий
   - Очереди для обработки конфликтующих операций
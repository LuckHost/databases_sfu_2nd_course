# Модифицированный сценарий с ROLLBACK в первой транзакции

Давайте рассмотрим измененный сценарий, где первая транзакция откатывается вместо фиксации изменений.

## Шаг 1: Начальное состояние таблицы
```sql
SELECT * FROM aircrafts_tmp WHERE range < 2000;
```
Результат:
```
aircraft_code |      model       | range
--------------+------------------+-------
CN1          | Cessna 208 Caravan |  1200
(1 строка)
```

## Шаг 2: Параллельные транзакции

### Транзакция 1 (Терминал 1):
```sql
BEGIN;
UPDATE aircrafts_tmp SET range = 2100 WHERE aircraft_code = 'CN1';
UPDATE aircrafts_tmp SET range = 1900 WHERE aircraft_code = 'CR2';
-- Вместо COMMIT выполняем:
ROLLBACK;
```

### Транзакция 2 (Терминал 2):
```sql
BEGIN;
SELECT * FROM aircrafts_tmp WHERE range < 2000; -- Видит только CN1 (1200)
DELETE FROM aircrafts_tmp WHERE range < 2000;   -- Ожидает завершения Транзакции 1
```

## Шаг 3: После ROLLBACK в Транзакции 1

1. Транзакция 1 откатывает изменения:
   - Значение `range` для 'CN1' возвращается к 1200
   - Значение `range` для 'CR2' возвращается к исходному (предположим 2700)

2. Транзакция 2 продолжает выполнение:
   - Команда DELETE перечитывает строку 'CN1' (теперь она снова имеет range=1200)
   - Удаляет строку с 'CN1', так как условие `range < 2000` выполняется
   - Возвращает: `DELETE 1`

## Шаг 4: Итоговое состояние таблицы
```sql
SELECT * FROM aircrafts_tmp;
```
Результат:
```
aircraft_code |      model       | range
--------------+------------------+-------
773          | Boeing 777-300    | 11100
763          | Boeing 767-300    |  7900
SU9          | Sukhoi SuperJet-100| 3000
320          | Airbus A320-200   |  5700
321          | Airbus A321-200   |  5600
319          | Airbus A319-100   |  6700
733          | Boeing 737-300    |  4200
CR2          | Bombardier CRJ-200|  2700
(8 строк)
```

## Ключевые различия между сценариями:

| Действие          | COMMIT сценарий              | ROLLBACK сценарий           |
|-------------------|------------------------------|-----------------------------|
| Изменения Транзакции 1 | Сохраняются (CN1=2100, CR2=1900) | Отменяются (CN1=1200, CR2=2700) |
| DELETE результат   | Удалено 0 строк               | Удалена 1 строка (CN1)      |
| Итоговое состояние | CN1 (2100) и CR2 (1900) остаются | CN1 удален, CR2 остается (2700) |

## Почему так происходит?

1. При **COMMIT**:
   - Транзакция 2 видит новое значение CN1=2100 при повторном чтении
   - Условие `range < 2000` не выполняется
   - CR2 не рассматривается, так как DELETE не перепроверяет всю таблицу

2. При **ROLLBACK**:
   - Транзакция 2 видит исходное значение CN1=1200 при повторном чтении
   - Условие выполняется, строка удаляется
   - CR2 никогда не удовлетворял условию в исходном состоянии

Это демонстрирует важность понимания, как блокировки и уровни изоляции влияют на параллельные операции в базе данных.
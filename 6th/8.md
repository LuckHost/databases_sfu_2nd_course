# Эксперимент с частичными индексами в базе "Авиаперевозки"

## Сравнение частичного и обычного индекса для бронирований

### 1. Подготовка индексов
```sql
-- Удаляем частичный индекс (если существует)
DROP INDEX IF EXISTS bookings_book_date_part_key;

-- Создаем обычный индекс по total_amount
CREATE INDEX bookings_total_amount_key ON bookings(total_amount);

-- Проверяем запрос с обычным индексом
EXPLAIN ANALYZE
SELECT * FROM bookings
WHERE total_amount > 1000000
ORDER BY book_date DESC;
```

### 2. Возвращаем частичный индекс для сравнения
```sql
-- Удаляем обычный индекс
DROP INDEX bookings_total_amount_key;

-- Создаем частичный индекс
CREATE INDEX bookings_book_date_part_key ON bookings(book_date)
WHERE total_amount > 1000000;

-- Проверяем тот же запрос с частичным индексом
EXPLAIN ANALYZE
SELECT * FROM bookings
WHERE total_amount > 1000000
ORDER BY book_date DESC;
```

## Более эффективный пример использования частичного индекса

### Ситуация: Частый поиск активных рейсов (status = 'Scheduled')

```sql
-- Частичный индекс для активных рейсов
CREATE INDEX idx_flights_active ON flights(flight_id, scheduled_departure)
WHERE status = 'Scheduled';

-- Запрос, который использует индекс
EXPLAIN ANALYZE
SELECT flight_id, flight_no, scheduled_departure
FROM flights
WHERE status = 'Scheduled' AND scheduled_departure > NOW()
ORDER BY scheduled_departure;
```

### Преимущества такого индекса:
1. **Меньший размер** - индекс содержит только активные рейсы (обычно ~10% от всех записей)
2. **Быстрый доступ** - оптимизирован именно для частого сценария запросов
3. **Автоматическое поддержание** - при изменении статуса рейса запись автоматически добавляется/удаляется из индекса

## Другой эффективный пример - билеты бизнес-класса:

```sql
-- Частичный индекс для дорогих билетов бизнес-класса
CREATE INDEX idx_business_expensive_tickets ON ticket_flights(ticket_no, amount)
WHERE fare_conditions = 'Business' AND amount > 50000;

-- Оптимизированный запрос
EXPLAIN ANALYZE
SELECT tf.ticket_no, t.passenger_name, tf.amount
FROM ticket_flights tf
JOIN tickets t ON tf.ticket_no = t.ticket_no
WHERE tf.fare_conditions = 'Business' AND tf.amount > 100000;
```

## Выводы:
1. Частичные индексы наиболее эффективны, когда:
   - Запросы фильтруют по конкретному условию (не диапазону)
   - Условие охватывает небольшую часть таблицы (10-20% записей)
   - Частота запросов с этим условием высока

2. В вашем эксперименте разница могла быть незначительной, потому что:
   - Условие `total_amount > 1000000` охватывает большой диапазон
   - PostgreSQL эффективно использует оба типа индексов для такого условия

3. Реальная выгода частичных индексов проявляется при:
   - Значительно меньшем размере индекса
   - Более специфичных условиях выборки
   - Частых запросах к определенному подмножеству данных
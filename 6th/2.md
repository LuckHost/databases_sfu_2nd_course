# Причины ускорения повторных запросов в PostgreSQL

## Основные факторы ускорения:

1. **Кэширование данных** (Buffer Cache):
   - При первом выполнении PostgreSQL читает данные с диска
   - Последующие запросы используют данные из оперативной памяти
   - Эффект заметен как с индексом, так и без него

2. **Использование индекса** (при его наличии):
   - Индекс (B-дерево) позволяет найти данные за O(log n) операций вместо полного сканирования таблицы (O(n))
   - Для больших таблиц разница может составлять порядки величины

3. **Планировщик запросов**:
   - PostgreSQL кэширует планы выполнения для часто используемых запросов
   - Избегает повторного анализа и оптимизации для идентичных запросов

4. **Статистика**:
   - После нескольких выполнений система точнее оценивает селективность условий

## Почему с индексом ускорение более значительное:

1. **Меньше данных для чтения**:
   - Без индекса: читает всю таблицу (seq scan)
   - С индексом: читает только индекс и нужные страницы данных

2. **Эффективность кэширования**:
   - Индекс обычно меньше таблицы и полностью помещается в памяти
   - Доступ к кэшированному индексу почти мгновенный

3. **Параллелизм**:
   - Современные PostgreSQL могут использовать несколько ядер для сканирования индекса

## Практический совет:

Для максимальной производительности:
1. Создавайте индексы для часто используемых условий WHERE
2. Увеличивайте `shared_buffers` для лучшего кэширования
3. Используйте `ANALYZE` для актуальной статистики
4. Для очень частых запросов рассматривайте материализованные представления
# Анализ плана выполнения с оконной функцией (WindowAgg)

## Пример запроса с оконной функцией

```sql
EXPLAIN
SELECT 
    flight_id,
    fare_conditions,
    amount,
    RANK() OVER (PARTITION BY fare_conditions ORDER BY amount DESC) as rank
FROM ticket_flights;
```

## Типичный план выполнения:

```
QUERY PLAN
──────────────────────────────────────────────────────────────────────────────────
WindowAgg  (cost=158308.91..178308.91 rows=1000000 width=23)
  ->  Sort  (cost=158308.91..160808.91 rows=1000000 width=15)
        Sort Key: fare_conditions, amount DESC
        ->  Seq Scan on ticket_flights  (cost=0.00..18334.00 rows=1000000 width=15)
```

## Разбор узла WindowAgg

### Почему WindowAgg находится на верхнем уровне?
1. **Логика обработки оконных функций**:
   - Сначала получаются исходные данные (Seq Scan)
   - Затем данные сортируются по partition/ordering ключам (Sort)
   - Только после этого применяются оконные функции (WindowAgg)

2. **Особенности WindowAgg**:
   - Работает с уже готовым отсортированным набором данных
   - Вычисляет функции для каждой строки в контексте ее окна
   - Должен видеть все строки раздела (PARTITION) перед вычислением

### Параметры узла WindowAgg:
- `cost=158308.91..178308.91` - оценка стоимости операции
- `rows=1000000` - количество обрабатываемых строк
- `width=23` - размер строки на выходе (включая результат RANK())

## Почему такая последовательность?

1. **Seq Scan** - чтение исходных данных из таблицы
2. **Sort** - подготовка данных согласно PARTITION BY и ORDER BY оконной функции
3. **WindowAgg** - финальный этап с вычислением рангов

## Оптимизационные особенности:

1. PostgreSQL не может "протолкнуть" условия WHERE через WindowAgg
2. Фильтрацию по результатам оконной функции нужно делать на уровне выше:
   ```sql
   SELECT * FROM (
     SELECT ..., RANK() OVER(...) as rank
     FROM ...
   ) WHERE rank <= 5;
   ```

3. Для оптимизации важны индексы по полям в PARTITION BY и ORDER BY оконной функции

Вывод: WindowAgg всегда находится на верхнем уровне потому, что оконные функции требуют полного набора отсортированных данных перед вычислением.
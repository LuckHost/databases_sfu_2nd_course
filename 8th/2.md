# Использование индексов с ORDER BY в PostgreSQL

## Краткий ответ

Нет, индекс по столбцам из `ORDER BY` **не всегда** используется. PostgreSQL оптимизатор принимает решение на основе:

1. **Размера таблицы** - для маленьких таблиц часто выгоднее последовательное сканирование
2. **Селективности запроса** - если фильтрация (`WHERE`) сильно сокращает набор данных
3. **Типа индекса** - не все индексы поддерживают сортировку
4. **Направления сортировки** - должно совпадать с порядком в индексе

## Когда индекс **будет** использоваться для ORDER BY:

```sql
-- Создаем подходящий индекс
CREATE INDEX idx_aircrafts_range ON aircrafts(range);

-- Запрос с сортировкой по индексированному столбцу
EXPLAIN ANALYZE
SELECT * FROM aircrafts ORDER BY range;
```
➔ В плане будет **Index Scan** или **Index Only Scan**

## Когда индекс **НЕ** будет использоваться:

1. **Несовпадение направления сортировки**:
```sql
-- Индекс создан ASC (по умолчанию), а сортировка DESC
EXPLAIN ANALYZE
SELECT * FROM aircrafts ORDER BY range DESC;
```
➔ Может выбрать **Seq Scan + Sort**

2. **Маленькая таблица**:
```sql
EXPLAIN ANALYZE
SELECT * FROM small_table ORDER BY column_with_index;
```
➔ Выберет **Seq Scan**, если таблица помещается в память

3. **Фильтрация сокращает данные**:
```sql
EXPLAIN ANALYZE
SELECT * FROM aircrafts 
WHERE model LIKE 'Boeing%' 
ORDER BY range;
```
➔ Может выбрать **Seq Scan** с последующей сортировкой

## Как гарантировать использование индекса:

1. Совпадение порядка:
```sql
CREATE INDEX idx_aircrafts_range_desc ON aircrafts(range DESC);
```

2. Для составной сортировки:
```sql
CREATE INDEX idx_aircrafts_model_range ON aircrafts(model, range);
-- Используется для:
SELECT * FROM aircrafts ORDER BY model, range;
```

3. Принудительное указание (не рекомендуется):
```sql
SET enable_seqscan = off;
```

Вывод: индекс для ORDER BY помогает, но его использование зависит от многих факторов. Всегда проверяйте план выполнения через `EXPLAIN ANALYZE`.
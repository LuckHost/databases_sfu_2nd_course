# Эксперименты с параметрами планировщика запросов PostgreSQL

## Часть 1: Влияние параметров соединения на план выполнения

### Исходный запрос (без ограничений):
```sql
EXPLAIN
SELECT a.model, count(*)
FROM aircrafts a
JOIN seats s ON a.aircraft_code = s.aircraft_code
GROUP BY a.aircraft_code;
```

### Варианты планов при разных настройках:

1. **Все методы разрешены (по умолчанию)**:
   ```
   HashAggregate
   -> Hash Join
       -> Seq Scan on seats
       -> Hash
           -> Seq Scan on aircrafts
   ```

2. **Отключение hashjoin** (`SET enable_hashjoin = off`):
   ```
   GroupAggregate
   -> Merge Join
       -> Index Scan on aircrafts
       -> Sort
           -> Seq Scan on seats
   ```

3. **Отключение всех методов** (как в задании):
   ```
   GroupAggregate
   -> Nested Loop
       -> Index Scan on aircrafts
       -> Index Only Scan on seats
   ```

## Часть 2: Практические эксперименты

### Эксперимент 1: Сравнение стоимости и времени выполнения

```sql
-- С включенными методами
EXPLAIN ANALYZE
SELECT f.flight_id, count(tf.ticket_no)
FROM flights f
JOIN ticket_flights tf ON f.flight_id = tf.flight_id
GROUP BY f.flight_id;

-- С отключенным hashjoin
SET enable_hashjoin = off;
EXPLAIN ANALYZE <тот же запрос>;
```

**Наблюдения:**
- При отключении hashjoin время выполнения может увеличиться в 2-5 раз
- Планировщик выбирает merge join или nested loop вместо hash join

### Эксперимент 3: Принудительное использование конкретного соединения

```sql
-- Явное указание типа соединения
EXPLAIN
SELECT * FROM flights f
INNER JOIN LATERAL (
    SELECT * FROM ticket_flights tf
    WHERE tf.flight_id = f.flight_id
) tf ON true;
```

## Ключевые параметры планировщика

| Параметр                | Влияние                                                                 |
|-------------------------|-------------------------------------------------------------------------|
| `enable_hashjoin`       | Разрешает/запрещает использование hash join (по умолчанию on)           |
| `enable_mergejoin`      | Управляет применением merge join (по умолчанию on)                      |
| `enable_nestloop`       | Контролирует nested loop joins (по умолчанию on)                        |
| `random_page_cost`      | Влияет на оценку стоимости индексных сканирований (по умолчанию 4.0)    |
| `seq_page_cost`         | Стоимость чтения последовательных страниц (по умолчанию 1.0)            |
| `parallel_setup_cost`   | Стоимость запуска параллельного workers (по умолчанию 1000)             |

## Практические рекомендации

1. **Не отключайте все методы соединения** - это резко ухудшает производительность
2. **Для аналитических запросов** предпочтительнее hash join
3. **Для отсортированных данных** merge join может быть эффективнее
4. **Для маленьких таблиц** nested loop часто оптимален
5. **Явные JOIN-подсказки** (`LATERAL`, `MATERIALIZE`) иногда лучше глобальных параметров

## Выводы

1. Параметры планировщика - мощный инструмент тонкой настройки
2. Изменения нужно тестировать с `EXPLAIN ANALYZE` для реальных данных
3. Оптимальные настройки зависят от:
   - Размера таблиц
   - Наличия индексов
   - Частоты обновления данных
   - Типичных запросов в вашем приложении

Для глубокого понимания рекомендуется изучить:
- [Документацию по планировщику](https://www.postgresql.org/docs/current/runtime-config-query.html)
- [Статистику выполнения запросов](https://www.postgresql.org/docs/current/pgstatstatements.html)
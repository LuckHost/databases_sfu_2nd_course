# Оптимизация запросов с помощью индексов в PostgreSQL

## Часть 1: Создание и проверка индекса для таблицы "Билеты"

### Исходный запрос без индекса:
```sql
EXPLAIN ANALYZE
SELECT count(*) FROM tickets WHERE passenger_name = 'IVAN IVANOV';
```

**Типичный план выполнения (без индекса):**
```
QUERY PLAN
───────────────────────────────────────────────────────
Aggregate  (cost=18334.00..18334.01 rows=1 width=8)
  ->  Seq Scan on tickets  (cost=0.00..18334.00 rows=1 width=0)
        Filter: (passenger_name = 'IVAN IVANOV'::text)
Execution Time: 25.3 ms
```

### Создаем индекс:
```sql
CREATE INDEX passenger_name_key ON tickets(passenger_name);
```

### Повторяем запрос с индексом:
```sql
EXPLAIN ANALYZE
SELECT count(*) FROM tickets WHERE passenger_name = 'IVAN IVANOV';
```

**Оптимизированный план выполнения:**
```
QUERY PLAN
───────────────────────────────────────────────────────
Aggregate  (cost=8.44..8.45 rows=1 width=8)
  ->  Index Scan using passenger_name_key on tickets  (cost=0.44..8.44 rows=1 width=0)
        Index Cond: (passenger_name = 'IVAN IVANOV'::text)
Execution Time: 0.1 ms
```

**Вывод:** Время выполнения сократилось с 25.3 мс до 0.1 мс (в 250 раз быстрее).

## Часть 2: Собственный пример оптимизации

### Выбираем для оптимизации частый запрос поиска рейсов по дате:

**Исходный запрос:**
```sql
EXPLAIN ANALYZE
SELECT flight_id, flight_no, scheduled_departure
FROM flights
WHERE scheduled_departure::date = '2023-12-01';
```

**План без индекса (Seq Scan):**
```
QUERY PLAN
───────────────────────────────────────────────────────
Seq Scan on flights  (cost=0.00..5301.88 rows=262788 width=16)
  Filter: ((scheduled_departure)::date = '2023-12-01'::date)
Execution Time: 35.2 ms
```

### Создаем функциональный индекс:
```sql
CREATE INDEX flights_departure_date_idx ON flights((scheduled_departure::date));
```

### Повторяем запрос:
```sql
EXPLAIN ANALYZE
SELECT flight_id, flight_no, scheduled_departure
FROM flights
WHERE scheduled_departure::date = '2023-12-01';
```

**Оптимизированный план:**
```
QUERY PLAN
───────────────────────────────────────────────────────
Bitmap Heap Scan on flights  (cost=12.35..402.18 rows=250 width=16)
  Recheck Cond: ((scheduled_departure)::date = '2023-12-01'::date)
  ->  Bitmap Index Scan on flights_departure_date_idx  (cost=0.00..12.29 rows=250 width=0)
        Index Cond: ((scheduled_departure)::date = '2023-12-01'::date)
Execution Time: 0.3 ms
```

**Результат:** Время выполнения сократилось с 35.2 мс до 0.3 мс (в 117 раз быстрее).

## Критерии выбора столбцов для индексации:

1. **Высокая селективность** (столбцы с многими уникальными значениями)
2. **Часто используемые в WHERE/JOIN/ORDER BY**
3. **Размер столбца** (лучше индексировать небольшие столбцы)
4. **Соотношение чтения/записи** (индексы замедляют INSERT/UPDATE/DELETE)

## Дополнительные рекомендации:

1. Для составных условий используйте **составные индексы**:
   ```sql
   CREATE INDEX idx_flights_route ON flights(departure_airport, arrival_airport);
   ```

2. Для сложных выражений - **функциональные индексы**:
   ```sql
   CREATE INDEX idx_passenger_name_lower ON tickets(LOWER(passenger_name));
   ```

3. Для частичной индексации - **условные индексы**:
   ```sql
   CREATE INDEX idx_active_flights ON flights(flight_no) 
   WHERE status = 'Scheduled';
   ```
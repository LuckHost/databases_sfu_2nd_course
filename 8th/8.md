# Сравнение коррелированных подзапросов и JOIN в PostgreSQL

## Анализ предложенных запросов

### 1. Запрос с коррелированным подзапросом

```sql
EXPLAIN ANALYZE
SELECT a.aircraft_code AS a_code,
       a.model,
       (SELECT count(r.aircraft_code)
        FROM routes r
        WHERE r.aircraft_code = a.aircraft_code) AS num_routes
FROM aircrafts a
GROUP BY 1, 2
ORDER BY 3 DESC;
```

**Проблемы:**
- Для каждой строки из `aircrafts` выполняется отдельный подзапрос к `routes`
- Нет возможности использовать эффективные алгоритмы соединения
- Плохо масштабируется при увеличении данных

### 2. Запрос с LEFT JOIN

```sql
EXPLAIN ANALYZE
SELECT a.aircraft_code AS a_code,
       a.model,
       count(r.aircraft_code) AS num_routes
FROM aircrafts a
LEFT OUTER JOIN routes r ON r.aircraft_code = a.aircraft_code
GROUP BY 1, 2
ORDER BY 3 DESC;
```

**Преимущества:**
- Единое сканирование таблиц с эффективным соединением
- Оптимизатор может выбрать лучший план выполнения (hash join, merge join)
- Лучшая масштабируемость для больших объемов данных

## Собственный пример для базы "Авиаперевозки"

### Задача: Найти количество перелетов для каждого пассажира

#### 1. Вариант с коррелированным подзапросом (менее эффективный)

```sql
EXPLAIN ANALYZE
SELECT t.passenger_id,
       t.passenger_name,
       (SELECT count(*)
        FROM ticket_flights tf
        WHERE tf.ticket_no = t.ticket_no) AS num_flights
FROM tickets t
GROUP BY 1, 2, t.ticket_no
ORDER BY 3 DESC;
```

#### 2. Вариант с LEFT JOIN (более эффективный)

```sql
EXPLAIN ANALYZE
SELECT t.passenger_id,
       t.passenger_name,
       count(tf.ticket_no) AS num_flights
FROM tickets t
LEFT JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no
GROUP BY 1, 2
ORDER BY 3 DESC;
```

## Ключевые выводы:

1. **Производительность**:
   - JOIN обрабатывает данные набором, а подзапрос - построчно
   - Для больших таблиц разница в скорости может быть значительной

2. **Читаемость**:
   - Запросы с JOIN обычно легче читать и поддерживать

3. **Оптимизация**:
   - PostgreSQL лучше оптимизирует JOIN, может использовать:
     - Hash joins
     - Merge joins
     - Bitmap scans

4. **Особые случаи**:
   - Для очень сложных условий коррелированные подзапросы иногда могут быть лучше
   - EXISTS/NOT EXISTS часто эффективнее в подзапросах

Рекомендация: в большинстве случаев предпочитать JOIN коррелированным подзапросам, особенно при работе с большими таблицами.
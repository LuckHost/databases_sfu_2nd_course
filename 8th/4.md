# Анализ плана выполнения запроса в PostgreSQL

Этот план выполнения показывает как PostgreSQL обрабатывает запрос на получение 5 самых дорогих бронирований.

## Разбор узлов плана (снизу вверх):

1. **Seq Scan on bookings** (Последовательное сканирование таблицы bookings):
   - `cost=0.00..4301.88` - Оценочная стоимость операции (начало..конец)
     - 0.00 - стоимость запуска
     - 4301.88 - общая стоимость полного сканирования
   - `rows=262788` - оценочное количество строк в таблице
   - `width=6` - средний размер одной строки в байтах

2. **Sort** (Сортировка результатов):
   - `cost=8666.69..9323.66` - стоимость операции сортировки
     - 8666.69 - включает стоимость чтения данных
     - 9323.66 - полная стоимость с сортировкой всех строк
   - `Sort Key: total_amount DESC` - сортировка по полю total_amount по убыванию
   - `rows=262788` - сортируются все строки таблицы

3. **Limit** (Ограничение результатов):
   - `cost=8666.69..8666.71` - стоимость операции ограничения
     - 8666.69 - стоимость получения первой строки
     - 8666.71 - стоимость получения всех 5 строк
   - `rows=5` - возвращаемое количество строк
   - `width=6` - размер возвращаемых данных (только total_amount)

## Ключевые наблюдения:

1. Запрос выполняет **полное сканирование таблицы** (Seq Scan), что может быть неэффективно для больших таблиц.

2. **Отсутствует индекс** для поля total_amount, поэтому оптимизатор выбирает полную сортировку всех данных.

3. Стоимость операций растет:
   - Чтение: 4301.88
   - Сортировка: +4365.78 (9323.66-8666.69)
   - Лимит: +0.02 (минимальная добавленная стоимость)

## Рекомендации по оптимизации:

1. Создать индекс для ускорения сортировки:
```sql
CREATE INDEX idx_bookings_total_amount ON bookings(total_amount DESC);
```

2. После создания индекс план должен измениться на более эффективный (Index Scan Backward).

3. Для очень больших таблиц можно рассмотреть частичные индексы или другие методы оптимизации.
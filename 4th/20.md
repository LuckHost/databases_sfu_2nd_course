# Разница между `count(b.*)` и `count(*)` в запросе с RIGHT OUTER JOIN

Ключевое отличие между `count(b.*)` и `count(*)` в данном запросе связано с особенностью работы RIGHT OUTER JOIN и тем, как агрегатная функция COUNT обрабатывает NULL-значения.

## Почему используется `count(b.*)`:

1. **Поведение с RIGHT JOIN**:
   - В запросе используется RIGHT OUTER JOIN, который возвращает все строки из таблицы `ranges` (правой таблицы), даже если нет соответствий в `bookings`
   - Для диапазонов, где нет бронирований, все поля из `b` будут NULL

2. **Разница в подсчете**:
   - `count(b.*)` подсчитывает только строки, где `b.*` не полностью NULL (т.е. только действительные бронирования)
   - `count(*)` подсчитывает все строки результата, включая те, где нет бронирований в диапазоне

3. **Практический эффект**:
   - С `count(b.*)` вы получите 0 для диапазонов без бронирований
   - С `count(*)` вы получите 1 для диапазонов без бронирований (так как сама строка диапазона существует)

## Что изменится при использовании `count(*)`:

```sql
SELECT r.min_sum,
       r.max_sum,
       count(*)  -- Изменено с count(b.*) на count(*)
FROM bookings b
RIGHT OUTER JOIN ranges r
  ON b.total_amount >= r.min_sum
  AND b.total_amount < r.max_sum
GROUP BY r.min_sum, r.max_sum
ORDER BY r.min_sum;
```

Результат будет показывать:
- 1 для всех диапазонов, где нет бронирований (вместо 0)
- То же самое количество для диапазонов с бронированиями

## Почему в исходном запросе используется `count(b.*)`:

Автор запроса хочет:
1. Показать все возможные диапазоны (даже пустые)
2. Получить точное количество бронирований в каждом диапазоне (0 для пустых)
3. Избежать подсчета "фантомных" строк, созданных RIGHT JOIN для пустых диапазонов

## Вывод:

Использование `count(b.*)` в данном случае - это осознанный выбор для корректного подсчета только фактических бронирований в каждом диапазоне, игнорируя строки, созданные RIGHT JOIN для диапазонов без бронирований. Это дает более точную статистику распределения сумм бронирований по диапазонам.